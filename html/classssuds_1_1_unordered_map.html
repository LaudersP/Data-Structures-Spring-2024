<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Data Structures Spring 2024: ssuds::UnorderedMap&lt; K, V &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Data Structures Spring 2024
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>ssuds</b></li><li class="navelem"><a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classssuds_1_1_unordered_map-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ssuds::UnorderedMap&lt; K, V &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html">UnorderedMapIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the iterator, which returns std::pairs (rather than our hidden node class)  <a href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0bb420e77f142bce81e4ef95197938e" id="r_ae0bb420e77f142bce81e4ef95197938e"><td class="memItemLeft" align="right" valign="top"><a id="ae0bb420e77f142bce81e4ef95197938e" name="ae0bb420e77f142bce81e4ef95197938e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UnorderedMap</b> ()</td></tr>
<tr class="memdesc:ae0bb420e77f142bce81e4ef95197938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br /></td></tr>
<tr class="separator:ae0bb420e77f142bce81e4ef95197938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fb3323f6abecdac1a5e48d0ee13e25" id="r_a74fb3323f6abecdac1a5e48d0ee13e25"><td class="memItemLeft" align="right" valign="top"><a id="a74fb3323f6abecdac1a5e48d0ee13e25" name="a74fb3323f6abecdac1a5e48d0ee13e25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UnorderedMap</b> (const <a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a> &amp;m)</td></tr>
<tr class="memdesc:a74fb3323f6abecdac1a5e48d0ee13e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-constructor. <br /></td></tr>
<tr class="separator:a74fb3323f6abecdac1a5e48d0ee13e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae49f747d0ea3bacc52dd8ba2864be01" id="r_aae49f747d0ea3bacc52dd8ba2864be01"><td class="memItemLeft" align="right" valign="top"><a id="aae49f747d0ea3bacc52dd8ba2864be01" name="aae49f747d0ea3bacc52dd8ba2864be01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>UnorderedMap</b> (<a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a> &amp;&amp;m)</td></tr>
<tr class="memdesc:aae49f747d0ea3bacc52dd8ba2864be01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-constructor. <br  />
 <br /></td></tr>
<tr class="separator:aae49f747d0ea3bacc52dd8ba2864be01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2a607102bed0453d42f5f5f0f52ca3" id="r_ade2a607102bed0453d42f5f5f0f52ca3"><td class="memItemLeft" align="right" valign="top"><a id="ade2a607102bed0453d42f5f5f0f52ca3" name="ade2a607102bed0453d42f5f5f0f52ca3"></a>
<a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a> &amp;other)</td></tr>
<tr class="memdesc:ade2a607102bed0453d42f5f5f0f52ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">=operator <br /></td></tr>
<tr class="separator:ade2a607102bed0453d42f5f5f0f52ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3979620a34f636482a1113baa7e97c6f" id="r_a3979620a34f636482a1113baa7e97c6f"><td class="memItemLeft" align="right" valign="top">V &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3979620a34f636482a1113baa7e97c6f">operator[]</a> (const K &amp;key)</td></tr>
<tr class="separator:a3979620a34f636482a1113baa7e97c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6147ad7079180e65cd2fe672ed10a6" id="r_acd6147ad7079180e65cd2fe672ed10a6"><td class="memItemLeft" align="right" valign="top"><a id="acd6147ad7079180e65cd2fe672ed10a6" name="acd6147ad7079180e65cd2fe672ed10a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> ()</td></tr>
<tr class="memdesc:acd6147ad7079180e65cd2fe672ed10a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements and sets the array back to its initial (INITIAL_MAP_CAPACITY) capacity. <br /></td></tr>
<tr class="separator:acd6147ad7079180e65cd2fe672ed10a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fbc80701e7ae7155b49cfc2b6a23e0" id="r_a97fbc80701e7ae7155b49cfc2b6a23e0"><td class="memItemLeft" align="right" valign="top"><a id="a97fbc80701e7ae7155b49cfc2b6a23e0" name="a97fbc80701e7ae7155b49cfc2b6a23e0"></a>
<a class="el" href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html">UnorderedMapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>find</b> (const K &amp;key) const</td></tr>
<tr class="memdesc:a97fbc80701e7ae7155b49cfc2b6a23e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we have a pair with this key. <br /></td></tr>
<tr class="separator:a97fbc80701e7ae7155b49cfc2b6a23e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573c26451426335a6c153a1406c4aaa8" id="r_a573c26451426335a6c153a1406c4aaa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a573c26451426335a6c153a1406c4aaa8">debug_output</a> (std::ostream &amp;os, bool show_nulls=true) const</td></tr>
<tr class="separator:a573c26451426335a6c153a1406c4aaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f32ef5a2c5dd0b9fd8030896cf8f6ed" id="r_a2f32ef5a2c5dd0b9fd8030896cf8f6ed"><td class="memItemLeft" align="right" valign="top">V&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f32ef5a2c5dd0b9fd8030896cf8f6ed">remove</a> (const K &amp;key)</td></tr>
<tr class="separator:a2f32ef5a2c5dd0b9fd8030896cf8f6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611a3b132a7ad20f50115225f7f1807" id="r_a1611a3b132a7ad20f50115225f7f1807"><td class="memItemLeft" align="right" valign="top"><a id="a1611a3b132a7ad20f50115225f7f1807" name="a1611a3b132a7ad20f50115225f7f1807"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> () const</td></tr>
<tr class="memdesc:a1611a3b132a7ad20f50115225f7f1807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of key-value pairs currently being stored. <br /></td></tr>
<tr class="separator:a1611a3b132a7ad20f50115225f7f1807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082d0bcef9b748406768316c0f1cf23c" id="r_a082d0bcef9b748406768316c0f1cf23c"><td class="memItemLeft" align="right" valign="top"><a id="a082d0bcef9b748406768316c0f1cf23c" name="a082d0bcef9b748406768316c0f1cf23c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>capacity</b> () const</td></tr>
<tr class="memdesc:a082d0bcef9b748406768316c0f1cf23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of available slots in the table. <br /></td></tr>
<tr class="separator:a082d0bcef9b748406768316c0f1cf23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9f372225d6bd38cd67a86b0924894" id="r_a63e9f372225d6bd38cd67a86b0924894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html">UnorderedMapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63e9f372225d6bd38cd67a86b0924894">begin</a> () const</td></tr>
<tr class="separator:a63e9f372225d6bd38cd67a86b0924894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bd260a21db192855c4eb7e70cb6371" id="r_a32bd260a21db192855c4eb7e70cb6371"><td class="memItemLeft" align="right" valign="top"><a id="a32bd260a21db192855c4eb7e70cb6371" name="a32bd260a21db192855c4eb7e70cb6371"></a>
<a class="el" href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html">UnorderedMapIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="memdesc:a32bd260a21db192855c4eb7e70cb6371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a special iterator which indicates the end of iteration, not finding a value, etc. <br /></td></tr>
<tr class="separator:a32bd260a21db192855c4eb7e70cb6371"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aa1a209dcf5a4dcef515a45ed2d37f194" id="r_aa1a209dcf5a4dcef515a45ed2d37f194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1a209dcf5a4dcef515a45ed2d37f194">internal_add</a> (std::pair&lt; K, V &gt; *pair)</td></tr>
<tr class="separator:aa1a209dcf5a4dcef515a45ed2d37f194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335a41c4077fb67572fda09492acda6f" id="r_a335a41c4077fb67572fda09492acda6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a335a41c4077fb67572fda09492acda6f">find_spot</a> (const K &amp;key) const</td></tr>
<tr class="separator:a335a41c4077fb67572fda09492acda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c359f5ef62aa03356bc4c7148f1019" id="r_a68c359f5ef62aa03356bc4c7148f1019"><td class="memItemLeft" align="right" valign="top"><a id="a68c359f5ef62aa03356bc4c7148f1019" name="a68c359f5ef62aa03356bc4c7148f1019"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>check_for_capacity</b> ()</td></tr>
<tr class="memdesc:a68c359f5ef62aa03356bc4c7148f1019"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function used to "grow" the table. I could (but currently don't) shrink the table. <br /></td></tr>
<tr class="separator:a68c359f5ef62aa03356bc4c7148f1019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a267a83673056c5c397105e47aaee6689" id="r_a267a83673056c5c397105e47aaee6689"><td class="memItemLeft" align="right" valign="top">std::pair&lt; K, V &gt; **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a267a83673056c5c397105e47aaee6689">mData</a></td></tr>
<tr class="separator:a267a83673056c5c397105e47aaee6689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91b26494ae861b9e4055c6689eebe75" id="r_ab91b26494ae861b9e4055c6689eebe75"><td class="memItemLeft" align="right" valign="top"><a id="ab91b26494ae861b9e4055c6689eebe75" name="ab91b26494ae861b9e4055c6689eebe75"></a>
std::hash&lt; K &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>mHashGenerator</b></td></tr>
<tr class="memdesc:ab91b26494ae861b9e4055c6689eebe75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generator we use to create hash codes for our keys. <br /></td></tr>
<tr class="separator:ab91b26494ae861b9e4055c6689eebe75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae967b0f662f0877de8057790f1faedb" id="r_aae967b0f662f0877de8057790f1faedb"><td class="memItemLeft" align="right" valign="top"><a id="aae967b0f662f0877de8057790f1faedb" name="aae967b0f662f0877de8057790f1faedb"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mSize</b></td></tr>
<tr class="memdesc:aae967b0f662f0877de8057790f1faedb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The current number of key-value pairs in this container. <br /></td></tr>
<tr class="separator:aae967b0f662f0877de8057790f1faedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca53348a94ba6a70e064b20a8591d7e" id="r_a0ca53348a94ba6a70e064b20a8591d7e"><td class="memItemLeft" align="right" valign="top"><a id="a0ca53348a94ba6a70e064b20a8591d7e" name="a0ca53348a94ba6a70e064b20a8591d7e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>mCapacity</b></td></tr>
<tr class="memdesc:a0ca53348a94ba6a70e064b20a8591d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in mData. <br /></td></tr>
<tr class="separator:a0ca53348a94ba6a70e064b20a8591d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae101c923c81d4518da10d1fa77a94cea" id="r_ae101c923c81d4518da10d1fa77a94cea"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae101c923c81d4518da10d1fa77a94cea">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a> &amp;m)</td></tr>
<tr class="separator:ae101c923c81d4518da10d1fa77a94cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63e9f372225d6bd38cd67a86b0924894" name="a63e9f372225d6bd38cd67a86b0924894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e9f372225d6bd38cd67a86b0924894">&#9670;&#160;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classssuds_1_1_unordered_map_1_1_unordered_map_iterator.html">UnorderedMapIterator</a> <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::begin </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an iterator to the first value in the map, if there is one (this iterator will be equal to the end iterator if there are none) </p>

</div>
</div>
<a id="a573c26451426335a6c153a1406c4aaa8" name="a573c26451426335a6c153a1406c4aaa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573c26451426335a6c153a1406c4aaa8">&#9670;&#160;</a></span>debug_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::debug_output </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>show_nulls</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>my "augmented" stream operator "overload". I did this so I could show the null entries if desired The real stream operator just calls this, passing false for the second parameter </p>

</div>
</div>
<a id="a335a41c4077fb67572fda09492acda6f" name="a335a41c4077fb67572fda09492acda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335a41c4077fb67572fda09492acda6f">&#9670;&#160;</a></span>find_spot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::find_spot </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper method which returns the index at which the key-value pair with the given key <em>does</em> appear or <em>would</em> appear (if it were in the table) </p>

</div>
</div>
<a id="aa1a209dcf5a4dcef515a45ed2d37f194" name="aa1a209dcf5a4dcef515a45ed2d37f194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1a209dcf5a4dcef515a45ed2d37f194">&#9670;&#160;</a></span>internal_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::internal_add </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; K, V &gt; *</td>          <td class="paramname"><span class="paramname"><em>pair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is used internally by check_for_capacity. If we decide that we need to grow, we can remove and re-add (using the [] operator), but if the thing we're adding is complex, deleting it and re-adding it could cause problems (in that case, this method is better) </p>

</div>
</div>
<a id="a3979620a34f636482a1113baa7e97c6f" name="a3979620a34f636482a1113baa7e97c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3979620a34f636482a1113baa7e97c6f">&#9670;&#160;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V &amp; <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the most fundamental, but also trickier methods. It is the way maps add and modify elements. The trick is, we use the key to find the right spot. If the elements not there (which means this is an add), we make a new entry with the value uninitialized BUT also return a reference to the value. If the user changes it like my_list[my_key] = my_value; then the new entry is fully initialized. But if the user does my_list[my_key]; it would create the entry, but the value will be some uninitialized value. std::unordered_map's also have this same behavior. </p>

</div>
</div>
<a id="a2f32ef5a2c5dd0b9fd8030896cf8f6ed" name="a2f32ef5a2c5dd0b9fd8030896cf8f6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f32ef5a2c5dd0b9fd8030896cf8f6ed">&#9670;&#160;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const K &amp;</td>          <td class="paramname"><span class="paramname"><em>key</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the pair with the given key and returns the corresponding value. It raises an out_of_range exception if not (the user should check for existence first with the find method) </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="ae101c923c81d4518da10d1fa77a94cea" name="ae101c923c81d4518da10d1fa77a94cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae101c923c81d4518da10d1fa77a94cea">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>os</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classssuds_1_1_unordered_map.html">UnorderedMap</a>&lt; K, V &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outputs the unorderd map in this form: {keyA: valueA, keyC: valueC, keyB: valueB} Note that this is an unordered set, so the output is in some arbitrary order </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a267a83673056c5c397105e47aaee6689" name="a267a83673056c5c397105e47aaee6689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267a83673056c5c397105e47aaee6689">&#9670;&#160;</a></span>mData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;K, V&gt;** <a class="el" href="classssuds_1_1_unordered_map.html">ssuds::UnorderedMap</a>&lt; K, V &gt;::mData</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An array of pair pointers. In a default constructor this is initialized to the size INITIAL_MAP_CAPACITY, and it "grows" when the load factor (mSize / mCapacity) reaches or exceeds MAX_LOAD_FACTOR </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_unordered_hash_map_8hpp_source.html">UnorderedHashMap.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
